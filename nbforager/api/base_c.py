"""Base for Connector."""

from __future__ import annotations

import logging
import re
import time
import urllib
from operator import itemgetter
from queue import Queue
from threading import Thread
from typing import Callable, Optional
from urllib.parse import ParseResult

import netports
import requests
from requests import Session, Response
from requests.exceptions import ReadTimeout, ConnectionError as RequestsConnectionError
from vhelpers import vlist, vparam

from nbforager import helpers, ami
from nbforager.api import extended_get
from nbforager.api.extended_get import ParamPath, DParamPath
from nbforager.exceptions import NbApiError
from nbforager.types_ import DAny, DStr, LDAny, LStr, DLInt, DList, LDList, DLStr
from nbforager.types_ import TLists, OUParam, LParam

LONERS: DLStr = {
    "any": ["q"],
    "dcim/devices/": ["airflow"],
    "ipam/aggregates/": ["family", "prefix"],
    "ipam/prefixes/": ["family", "within_include"],
    "ipam/ip-addresses/": ["family"],
    "ipam/vlan-groups/": ["site"],
    "extras/content-types/": ["id", "app_label", "model"],
}
"""Filtering parameters in an OR manner."""


class BaseC:
    """Base for Connector."""

    path = ""
    _slices = [
        "id",
        "name",
        "slug",
        "display",
        "prefix",
        "address",
        "cid",
        "vid",
        "asn",
        "device_id",
    ]
    _init_params = [
        "host",
        "token",
        "scheme",
        "port",
        "verify",
        "limit",
        "url_length",
        "threads",
        "interval",
        "timeout",
        "max_retries",
        "sleep",
        "loners",
    ]
    _extra_keys: DLStr = {
        "ipam/": [
            # ipam/aggregates, ipam/prefixes, ipam/ip_addresses
            "_ipv4",
            "_aggregate",
            "_super_prefix",
            "_sub_prefixes",
            "_ip_addresses",
            # evonetbox
            "overlapped",
            "warnings",
            "nbnets",
            "nbnets__subnets",
        ],
        "dcim/devices/": [
            # UI interfaces
            "_interfaces",
            "_front_ports",
            "_rear_ports",
            "_console_ports",
            "_console_server_ports",
            "_power_ports",
            "_power_outlets",
            "_module_bays",
            "_device_bays",
            "_inventory_items",
            # UI virtual_chassis
            "_vc_members",
        ],
        "dcim/interfaces/": [
            "_ip_addresses",
        ],
        "virtualization/virtual-machines/": [
            "_interfaces",
        ],
        "virtualization/interfaces/": [
            "_ip_addresses",
        ],
    }
    """Extra keys are reserved for internal usage by this package.

    The key represents the app/model path, while the value is the key name that can be used 
    to store additional data generated by this package.
    """

    def __init__(self, **kwargs):
        """Initialize BaseC.

        :param str host: Netbox host name.

        :param str token: Netbox token.

        :param str scheme: Access method: `https` or `http`. Default is `https`.

        :param int port: TCP port.
            Default is `443` for scheme=`https`, `80` for scheme=`http`.

        :param bool verify: Transport Layer Security.
            `True` - A TLS certificate required,
            `False` - Requests will accept any TLS certificate.
            Default is `True`.

        :param int limit: Split the query to multiple requests
            if the count of objects exceeds this value. Default is `1000`.

        :param int url_length: Split the query to multiple requests
            if the URL length exceeds maximum length due to a long list of
            GET parameters. Default is `2047`.

        :param int threads: Threads count. <=1 is loop mode, >=2 is threading mode.
            Default id `1`.

        :param float interval: Wait this time between the threading requests (seconds).
            Default is `0`. Useful to optimize session spikes and achieve
            script stability in Docker with limited resources.

        :param int timeout: Session timeout (seconds). Default is `60`.

        :param int max_retries: Retries the request multiple times if the Netbox API
            does not respond or responds with a timeout. Default is `0`. This is useful
            for scheduled scripts in cron jobs, when the connection to Netbox server is
            not stable.

        :param int sleep: Interval (seconds) before the next retry after
            session timeout reached. Default is `10`.

        :param bool strict: When querying objects by tag, if there are no tags present,
            the Netbox API response returns a status_code=400.
            True - ConnectionError is raised when status_code=400.
            False - WARNING message is logged and an empty list is returned with status_code=200.
            Default is `False`.

        :param bool extended_get: True - Extend filtering parameters in GET request,
            ``{parameter}`` can be used instead of ``{parameter}_id``. Default is `True`.

        :param dict loners: Set :ref:`Filtering parameters in an OR manner`.
        """
        self.host: str = _init_host(**kwargs)
        self.token: str = str(kwargs.get("token") or "")
        self.scheme: str = _init_scheme(**kwargs)
        self.port: int = _init_port(**kwargs)
        self.verify: bool = _init_verify(**kwargs)
        self.limit: int = int(kwargs.get("limit") or 1000)
        self.url_length = int(kwargs.get("url_length") or 2047)
        # Multithreading
        self.threads: int = _init_threads(**kwargs)
        self.interval: float = float(kwargs.get("interval") or 0.0)
        # Errors processing
        self.timeout: int = int(kwargs.get("timeout") or 60)
        self.max_retries: int = int(kwargs.get("max_retries") or 0)
        self.sleep: int = int(kwargs.get("sleep") or 10)
        self.strict: bool = bool(kwargs.get("strict"))
        # Settings
        self.extended_get: bool = bool(kwargs.get("extended_get"))
        self.loners: DLStr = dict(kwargs.get("loners") or {})

        self._loners: LStr = self._init_loners()
        self._results: LDAny = []  # cache for received objects from Netbox
        self._session: Session = requests.session()

    def __repr__(self) -> str:
        """__repr__."""
        name = self.__class__.__name__
        return f"<{name}: {self.host}>"

    # ============================= property =============================

    @property
    def url(self) -> str:
        """URL to the API endpoint of the Netbox object."""
        return f"{self.url_base}{self.path}"

    @property
    def url_ui(self) -> str:
        """URL to the UI endpoint to the Netbox object."""
        return ami.url_to_ui(self.url)

    @property
    def url_base(self) -> str:
        """Base URL without the application and model path."""
        port = 0
        if self.scheme == "http":
            if self.port != 80:
                port = self.port
        elif self.scheme == "https":
            if self.port != 443:
                port = self.port

        url = f"{self.scheme}://{self.host}"
        if port:
            url += f":{port}"
        return f"{url}/api/"

    # ============================== query ===============================

    def _query(self, path: str, params: OUParam = None) -> LDAny:
        """Retrieve data from the Netbox.

        :param path: Section of the URL that points to the model.
        :param params: Parameters to request from the Netbox.

        :return: A list of the Netbox objects.

        :example:
            query(path="ipam/ip-addresses/", params=[("status", "active")]) ->
            [{"id": 1, "address": "", ...}, ...]
        """
        if params is None:
            params = []
        params_d = vparam.to_dict(params)
        return self._query_loop(path, params_d)

    def _query_params_ld(self, params_ld: LDList) -> LDAny:
        """Retrieve data from the Netbox.

        :param params_ld: Parameters to request from the Netbox.

        :return: A list of the Netbox objects.
        """
        self._results = []

        # slice params
        params_ld = helpers.slice_params_ld(
            url=self.url,
            max_len=self.url_length,
            keys=self._slices,
            params_ld=params_ld,
        )

        # threads
        if self.threads > 1:
            counts_w_params: LDAny = self._query_pages_count(params_ld)
            params_ld_: LDAny = self._slice_params_counters(counts_w_params)
            self._query_threads(method=self._query_data_thread, params_ld=params_ld_)
        # loop
        else:
            for params_d in params_ld:
                results_: LDAny = self._query_loop(self.path, params_d)
                self._results.extend(results_)

        # save
        results: LDAny = sorted(self._results, key=itemgetter("id"))
        results = vlist.no_dupl(results)
        self._results = []
        return results

    def _query_count(self, path: str, params_d: DAny) -> None:
        """Retrieve counters of interested objects from the Netbox.

        :param path: Section of the URL that points to the model.
        :param params_d: Parameters to request from the Netbox.

        :return: None. Update self object.
        """
        params_d_ = params_d.copy()
        params_d_["brief"] = 1
        params_d_["limit"] = 1
        params_l: LParam = vparam.from_dict(params_d_)
        url = f"{self.url_base}{path}?{urllib.parse.urlencode(params_l)}"
        response: Response = self._retry_requests(url)

        count = 0
        if response.ok:
            data: DAny = helpers.decode_response_d(response)
            count = int(data["count"])

        result = {"count": count, "params_d": params_d}
        self._results.append(result)

    def _query_loop(self, path: str, params_d: DList) -> LDAny:
        """Retrieve data from Netbox in loop mode.

        If the number of items in the result exceeds the limit, iterate through the offset
        in a loop mode.

        :param path: Section of the URL that points to the model.
        :param params_d: Parameters to request from the Netbox.

        :return: Netbox objects. Update self _results.
        """
        is_brief: bool = "brief" in params_d
        is_offset: bool = "offset" in params_d

        if not is_brief:
            params_d = self._add_default_limit_offset(params_d)
        params_l: LParam = vparam.from_dict(params_d)
        url = f"{self.url_base}{path}?{urllib.parse.urlencode(params_l)}"

        results: LDAny = []
        while True:
            response: Response = self._retry_requests(url)

            # no data if strict is False and status 400
            if not response.ok:
                break

            data: DAny = helpers.decode_response_d(response)
            results_: LDAny = list(data["results"])
            results.extend(results_)

            # retrieve next offset from Response
            if is_offset:
                break
            if url_next := str(data.get("next") or ""):
                url = url_next
            else:
                break

            # Sleep before the next iteration to reduce server load
            if self.interval:
                time.sleep(self.interval)

        return results

    def _query_data_thread(self, path: str, params_d: DAny) -> None:
        """Retrieve data from the Netbox and appends results to the internal results list.

        If the params_d does not have `offset` and the received Response contains "next" URL,
            the method will recurse to fetch the next set of data.

        :param path: Section of the URL that points to the model.
        :param params_d: Parameters to request from the Netbox.

        :return: Netbox objects. Update self _results.
        """
        params_d = self._add_default_limit_offset(params_d)
        params_l: LParam = vparam.from_dict(params_d)
        url = f"{self.url_base}{path}?{urllib.parse.urlencode(params_l)}"

        response: Response = self._retry_requests(url)

        # no data if strict is False and status 400
        if not response.ok:
            return

        data: DAny = helpers.decode_response_d(response)
        results_: LDAny = list(data["results"])
        self._results.extend(results_)

        # threading mode manage offset in top level method
        if "offset" in params_d:
            return

        # retrieve next offset from Response
        if url_next := str(data.get("next") or ""):
            url_o: ParseResult = urllib.parse.urlparse(url_next)
            params_d_: DAny = urllib.parse.parse_qs(url_o.query)
            results_ = self._query_loop(path=path, params_d=params_d_)
            self._results.extend(results_)

    def _query_pages_count(self, params_ld: LDList) -> LDAny:
        """Retrieve counters of interested objects from Netbox in threaded mode.

        :param params_ld: Parameters to request from the Netbox.

        :return: List of dict with counters and parameters of interested objects.
        """
        self._results = []
        self._query_threads(method=self._query_count, params_ld=params_ld)
        results: LDAny = self._results
        self._results = []
        return results

    def _query_threads(self, method: Callable, params_ld: LDAny) -> None:
        """Retrieve data from Netbox in threaded mode.

        :param method: Method that need call with parameters.
        :param params_ld: Parameters to request from the Netbox.

        :return: None. Save results to self._results.
        """
        queue: Queue = Queue()
        for params_d in params_ld:
            queue.put((method, params_d))

        for idx in range(self.threads):
            if self.interval:
                time.sleep(self.interval)
            thread = Thread(name=f"Thread-{idx}", target=self._run_queue, args=(queue,))
            thread.start()
        queue.join()

    def _run_queue(self, queue: Queue) -> None:
        """Process tasks from the queue.

        This method dequeues and executes tasks until the queue is empty.
        Each task is expected to be a callable method with its corresponding params_d parameters.

        :param queue: A queue containing (method, params_d) pairs to be executed.

        :return: None. Update self _results list.
        """
        while not queue.empty():
            method, params_d = queue.get()
            method(self.path, params_d)
            queue.task_done()

    # ============================== helper ==============================

    def _add_default_limit_offset(self, params_d: DList) -> DList:
        """Add `limit` and `offset` default values to the params_d if they are not already present.

        :param params_d: Parameters that need to update.
        :return: Updated parameters.
        """
        params_d = params_d.copy()
        if "limit" not in params_d:
            params_d["limit"] = [self.limit]
        if "offset" not in params_d:
            params_d["offset"] = [0]
        return params_d

    def _get_d(self) -> DAny:
        """Get dictionary from the Netbox.

        :return: Dictionary.

        :raise: ConnectionError if status_code is not 200.
        """
        response: Response = self._retry_requests(url=self.url)
        if response.ok:
            return helpers.decode_response_d(response)

        # error
        msg = self._msg_status_code(response)
        raise ConnectionError(f"Netbox server error: {msg}")

    def _get_l(self) -> LDAny:
        """Get list from the Netbox.

        :return: List of dictionary.

        :raise: ConnectionError if status_code is not 200.
        """
        response: Response = self._retry_requests(url=self.url)
        if response.ok:
            return helpers.decode_response_l(response)

        # error
        msg = self._msg_status_code(response)
        raise ConnectionError(f"Netbox server error: {msg}")

    def _retry_requests(self, url: str) -> Response:
        """Perform an HTTP GET request with automatic retry logic.

        This method repeatedly attempts to fetch the given URL.
        It is designed to handle temporary network or server issues (such as
        timeouts or Netbox overloads) by retrying the request after a `sleep` interval.

        The method will:
          - Return the response if the status code indicates success (2xx).
          - Raise a `ConnectionError` if a connection failure occurs.
          - Return response with empty data if status code is 400 and `strict` is False.
          - Retry the request up to `max_retries` times if a ReadTimeout occurs.

        :param url: The URL to send the GET request to.

        :return: Response: The HTTP response object, either from the final successful
            request or a generated 504 response if all retries failed.

        :raises ConnectionError: If a persistent connection issue occurs or
            the limit of retries is reached.
        """
        max_retries = self.max_retries + 1
        sleep = self.sleep
        counter = 0

        while counter < max_retries:
            counter += 1
            try:
                response: Response = self._session.get(
                    url=url,
                    headers=self._headers(),
                    verify=self.verify,
                    timeout=float(self.timeout),
                )
            except ReadTimeout:
                attempts = f"{counter} of {self.max_retries}"
                msg = f"Session timeout={self.timeout!r}sec reached, {attempts=}."
                logging.warning(msg)
                if counter < max_retries:
                    msg = f"Next attempt after {sleep=} sec."
                    logging.warning(msg)
                    time.sleep(sleep)
                continue
            except RequestsConnectionError as ex:
                raise ConnectionError(f"Netbox connection error: {ex}") from ex

            if response.ok:
                return response

            self._handle_server_error(response)
            return response

        return self._response_gateway_timeout()

    def _handle_server_error(self, response: Response) -> None:
        """Handle server errors based on the response status code.

        If strict is False and the status is 400, empty data should be returned.

        :param response: The response object to evaluate.
        :return: None. Raises ConnectionError for various server error conditions.
        :raise ConnectionError: For various server error conditions.
        """
        if 200 <= response.status_code < 300:
            return

        msg = self._msg_status_code(response)

        # Handle 5xx – server errors
        if 500 <= response.status_code < 600:
            raise ConnectionError(f"Netbox server error: {msg}")

        # Handle 403 – authentication or permission error
        if response.status_code == 403:
            if re.search("Invalid token", response.text, re.I):
                raise ConnectionError(f"Netbox credentials error: {msg}")

        if self.strict:
            raise ConnectionError(f"ConnectionError: {msg}")

        # Handle 400 – bad request, only warn if not strict
        if response.status_code == 400:
            logging.warning(msg)
            return None

        # Catch-all for other unexpected codes (non-2xx)
        raise ConnectionError(f"ConnectionError: {msg}.")

    def _response_gateway_timeout(self) -> Response:
        """Create Response when `max_retries` are reached.

        :return: Response object with status code 504 (Gateway Timeout).
        """
        max_retries = self.max_retries
        msg = f"{max_retries=} reached."
        logging.warning(msg)

        response = Response()
        response.status_code = 504
        response.reason = "Gateway Timeout"
        response._content = str.encode(msg)  # pylint: disable=protected-access
        return response

    def _validate_params(self, **kwargs) -> LDList:
        """Validate and update params.

        Remove duplicates, convert single items to list, replace {name} to {name}_id,
        split the parallel parameters into separate items.
        :param kwargs: Filter parameters to update.

        :return: Updated parameters.
        """
        params_d: DList = _lists_wo_dupl(kwargs)
        params_d = self._change_params_name_to_id(params_d)
        params_d = self._change_params_exceptions(params_d)
        params_ld: LDList = helpers.make_combinations(self._loners, params_d)
        params_ld = helpers.change_params_or(params_ld)
        return params_ld

    def _headers(self) -> DStr:
        """Session headers with token."""
        headers = {
            "Authorization": f"Token {self.token}",
            "Content-Type": "application/json",
        }
        return headers

    def _check_extra_keys(self, items: LDAny) -> None:
        """Check if extra keys are present in the data.

        The Netbox REST API returns the object as a dictionary.
        NbForager inject extra key/value pairs into Netbox object.
        Need to make sure that these keys are not used in Netbox REST API.

        :return: None.
        :raise NbApiError: Reserved key is found in the Netbox object.
        """
        for data in items:
            url_o: ParseResult = urllib.parse.urlparse(data["url"])
            for path, extra_keys in self._extra_keys.items():
                if url_o.path.find(path) > -1:
                    if keys := set(extra_keys).intersection(data):
                        raise NbApiError(f"NbForager extra {keys=} detected in {self.url}.")

    def _slice_params_counters(self, results: LDAny) -> LDAny:
        """Generate sliced parameters based on counts in results.

        To request data in threading mode need have all params with offsets.
        :param results: List of dicts with params_d and related counts of objects.
        :return: Sliced parameters.
        """
        params: LDAny = []
        for result in results:
            count = result["count"]
            params_d = result["params_d"]
            if not result["count"]:
                continue
            params_: LDAny = helpers.generate_offsets(count, self.limit, params_d)
            params.extend(params_)
        return params

    # =========================== helpers ===========================

    def _init_loners(self) -> LStr:
        """Initialize loners filtering parameters."""
        loners_d: DAny = self.loners or LONERS
        loners: LStr = list(loners_d.get("any") or [])
        for path, loners_ in loners_d.items():
            if self.path == path:
                loners.extend(list(loners_))
        return loners

    def _change_params_name_to_id(self, params_d: DList) -> DList:
        """Change parameter with name to parameter with id.

        Request all related objects from the Netbox, find the name, and replace it with the ID.

        Described in: nb_api.rst Extended filtering parameters

        :param params_d: Parameters that need to update.
        :return: Updated parameters.
        """
        need_delete: LStr = []
        need_add: DLInt = {}

        if self.extended_get is True:
            mapping_d: DParamPath = extended_get.data(self.path)
            need_change: DList = extended_get.need_change(params_d, mapping_d)

            for name, values in need_change.items():
                param_path: ParamPath = mapping_d[name]
                path = param_path.path
                key = param_path.key

                response: LDAny = self._query(path)

                if ids := [d["id"] for d in response if d[key] in values]:
                    need_delete.extend([name, f"or_{name}"])
                    name_id = f"{name}_id"
                    need_add.setdefault(name_id, []).extend(ids)

        params_d_: DList = {k: v for k, v in params_d.items() if k not in need_delete}
        params_d_.update(need_add)
        return params_d_

    def _change_params_exceptions(self, params_d: DList) -> DList:
        """Process exceptions that work differently than

        Described in: nb_api.rst Extended filtering parameters

        ipam/vlan-groups/ need site=1 instead of site_id=1.

        :param params_d: Parameters that need to update.
        :return: Updated parameters.
        """
        if self.extended_get is False:
            return params_d

        params_d_: DList = {}
        for key, params in params_d.items():
            if self.path == "ipam/vlan-groups/":
                if key == "site_id":
                    key = "site"
            params_d_[key] = params
        return params_d_

    @staticmethod
    def _msg_status_code(response: Optional[Response]) -> str:
        """Return message ready for logging ConnectionError."""
        if not isinstance(response, Response):
            return ""

        status_code = 0
        if hasattr(response, "status_code"):
            status_code = response.status_code

        text = ""
        if hasattr(response, "text"):
            text = response.text
        if re.search("<title>Page Not Found.+", text):
            text = "Page Not Found."

        url = ""
        if hasattr(response, "url"):
            url = response.url

        return f"{status_code=} {text=} {url=}"


# ============================= helpers ==========================


def _init_host(**kwargs) -> str:
    """Initialize Netbox host name."""
    host = str(kwargs.get("host") or "")
    if not host:
        raise ValueError("Host is required.")
    return host


def _init_port(**kwargs) -> int:
    """Initialize port."""
    if port := int(kwargs.get("port") or 0):
        if netports.check_port(port, strict=True):
            return port

    port = 443
    scheme = str(kwargs.get("scheme") or "").lower()
    if scheme == "http":
        port = 80
    return port


def _init_scheme(**kwargs) -> str:
    """Initialize scheme: https or http."""
    scheme = str(kwargs.get("scheme") or "").lower()
    expected = ["https", "http"]
    if scheme not in expected:
        raise ValueError(f"{scheme=}, {expected=}")
    return scheme


def _init_threads(**kwargs) -> int:
    """Initialize threads count, default 1."""
    threads = int(kwargs.get("threads") or 1)
    threads = max(threads, 1)
    return int(threads)


def _init_verify(**kwargs) -> bool:
    """Initialize verify. False - Requests will accept any TLS certificate."""
    verify = kwargs.get("verify")
    if verify is None:
        return True
    return bool(verify)


def _lists_wo_dupl(kwargs: DAny) -> DList:
    """Convert single values to list and remove duplicate values from params.

    :param kwargs: A dictionary containing the parameters with single or multiple values.
    :return: A dictionary with list of values where duplicates removed.
    """
    params_d: DAny = {}
    for key, value in kwargs.items():
        if isinstance(value, TLists):
            params_d[key] = vlist.no_dupl(list(value))
        else:
            params_d[key] = [value]
    return params_d
